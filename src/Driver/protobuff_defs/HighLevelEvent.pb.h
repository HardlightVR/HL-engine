// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: HighLevelEvent.proto

#ifndef PROTOBUF_HighLevelEvent_2eproto__INCLUDED
#define PROTOBUF_HighLevelEvent_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3000000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3000000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace NullSpaceIPC {

// Internal implementation detail -- do not call these.
void protobuf_AddDesc_HighLevelEvent_2eproto();
void protobuf_AssignDesc_HighLevelEvent_2eproto();
void protobuf_ShutdownFile_HighLevelEvent_2eproto();

class CurveHaptic;
class CurveHaptic_Sample;
class HighLevelEvent;
class PlaybackEvent;
class RealtimeHaptic;
class RealtimeHaptic_Magnitude;
class SimpleHaptic;

enum PlaybackEvent_Command {
  PlaybackEvent_Command_UNKNOWN = 0,
  PlaybackEvent_Command_PAUSE = 1,
  PlaybackEvent_Command_UNPAUSE = 2,
  PlaybackEvent_Command_CANCEL = 3,
  PlaybackEvent_Command_PlaybackEvent_Command_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  PlaybackEvent_Command_PlaybackEvent_Command_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool PlaybackEvent_Command_IsValid(int value);
const PlaybackEvent_Command PlaybackEvent_Command_Command_MIN = PlaybackEvent_Command_UNKNOWN;
const PlaybackEvent_Command PlaybackEvent_Command_Command_MAX = PlaybackEvent_Command_CANCEL;
const int PlaybackEvent_Command_Command_ARRAYSIZE = PlaybackEvent_Command_Command_MAX + 1;

const ::google::protobuf::EnumDescriptor* PlaybackEvent_Command_descriptor();
inline const ::std::string& PlaybackEvent_Command_Name(PlaybackEvent_Command value) {
  return ::google::protobuf::internal::NameOfEnum(
    PlaybackEvent_Command_descriptor(), value);
}
inline bool PlaybackEvent_Command_Parse(
    const ::std::string& name, PlaybackEvent_Command* value) {
  return ::google::protobuf::internal::ParseNamedEnum<PlaybackEvent_Command>(
    PlaybackEvent_Command_descriptor(), name, value);
}
// ===================================================================

class SimpleHaptic : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:NullSpaceIPC.SimpleHaptic) */ {
 public:
  SimpleHaptic();
  virtual ~SimpleHaptic();

  SimpleHaptic(const SimpleHaptic& from);

  inline SimpleHaptic& operator=(const SimpleHaptic& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SimpleHaptic& default_instance();

  void Swap(SimpleHaptic* other);

  // implements Message ----------------------------------------------

  inline SimpleHaptic* New() const { return New(NULL); }

  SimpleHaptic* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SimpleHaptic& from);
  void MergeFrom(const SimpleHaptic& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(SimpleHaptic* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated uint32 regions = 1;
  int regions_size() const;
  void clear_regions();
  static const int kRegionsFieldNumber = 1;
  ::google::protobuf::uint32 regions(int index) const;
  void set_regions(int index, ::google::protobuf::uint32 value);
  void add_regions(::google::protobuf::uint32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      regions() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_regions();

  // optional uint32 effect = 2;
  void clear_effect();
  static const int kEffectFieldNumber = 2;
  ::google::protobuf::uint32 effect() const;
  void set_effect(::google::protobuf::uint32 value);

  // optional float strength = 3;
  void clear_strength();
  static const int kStrengthFieldNumber = 3;
  float strength() const;
  void set_strength(float value);

  // optional float duration = 4;
  void clear_duration();
  static const int kDurationFieldNumber = 4;
  float duration() const;
  void set_duration(float value);

  // @@protoc_insertion_point(class_scope:NullSpaceIPC.SimpleHaptic)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > regions_;
  mutable int _regions_cached_byte_size_;
  ::google::protobuf::uint32 effect_;
  float strength_;
  float duration_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_HighLevelEvent_2eproto();
  friend void protobuf_AssignDesc_HighLevelEvent_2eproto();
  friend void protobuf_ShutdownFile_HighLevelEvent_2eproto();

  void InitAsDefaultInstance();
  static SimpleHaptic* default_instance_;
};
// -------------------------------------------------------------------

class CurveHaptic_Sample : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:NullSpaceIPC.CurveHaptic.Sample) */ {
 public:
  CurveHaptic_Sample();
  virtual ~CurveHaptic_Sample();

  CurveHaptic_Sample(const CurveHaptic_Sample& from);

  inline CurveHaptic_Sample& operator=(const CurveHaptic_Sample& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CurveHaptic_Sample& default_instance();

  void Swap(CurveHaptic_Sample* other);

  // implements Message ----------------------------------------------

  inline CurveHaptic_Sample* New() const { return New(NULL); }

  CurveHaptic_Sample* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CurveHaptic_Sample& from);
  void MergeFrom(const CurveHaptic_Sample& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(CurveHaptic_Sample* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional float time = 1;
  void clear_time();
  static const int kTimeFieldNumber = 1;
  float time() const;
  void set_time(float value);

  // optional float magnitude = 2;
  void clear_magnitude();
  static const int kMagnitudeFieldNumber = 2;
  float magnitude() const;
  void set_magnitude(float value);

  // @@protoc_insertion_point(class_scope:NullSpaceIPC.CurveHaptic.Sample)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  float time_;
  float magnitude_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_HighLevelEvent_2eproto();
  friend void protobuf_AssignDesc_HighLevelEvent_2eproto();
  friend void protobuf_ShutdownFile_HighLevelEvent_2eproto();

  void InitAsDefaultInstance();
  static CurveHaptic_Sample* default_instance_;
};
// -------------------------------------------------------------------

class CurveHaptic : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:NullSpaceIPC.CurveHaptic) */ {
 public:
  CurveHaptic();
  virtual ~CurveHaptic();

  CurveHaptic(const CurveHaptic& from);

  inline CurveHaptic& operator=(const CurveHaptic& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CurveHaptic& default_instance();

  void Swap(CurveHaptic* other);

  // implements Message ----------------------------------------------

  inline CurveHaptic* New() const { return New(NULL); }

  CurveHaptic* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CurveHaptic& from);
  void MergeFrom(const CurveHaptic& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(CurveHaptic* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef CurveHaptic_Sample Sample;

  // accessors -------------------------------------------------------

  // repeated uint64 regions = 1;
  int regions_size() const;
  void clear_regions();
  static const int kRegionsFieldNumber = 1;
  ::google::protobuf::uint64 regions(int index) const;
  void set_regions(int index, ::google::protobuf::uint64 value);
  void add_regions(::google::protobuf::uint64 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
      regions() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
      mutable_regions();

  // repeated .NullSpaceIPC.CurveHaptic.Sample samples = 2;
  int samples_size() const;
  void clear_samples();
  static const int kSamplesFieldNumber = 2;
  const ::NullSpaceIPC::CurveHaptic_Sample& samples(int index) const;
  ::NullSpaceIPC::CurveHaptic_Sample* mutable_samples(int index);
  ::NullSpaceIPC::CurveHaptic_Sample* add_samples();
  ::google::protobuf::RepeatedPtrField< ::NullSpaceIPC::CurveHaptic_Sample >*
      mutable_samples();
  const ::google::protobuf::RepeatedPtrField< ::NullSpaceIPC::CurveHaptic_Sample >&
      samples() const;

  // @@protoc_insertion_point(class_scope:NullSpaceIPC.CurveHaptic)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint64 > regions_;
  mutable int _regions_cached_byte_size_;
  ::google::protobuf::RepeatedPtrField< ::NullSpaceIPC::CurveHaptic_Sample > samples_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_HighLevelEvent_2eproto();
  friend void protobuf_AssignDesc_HighLevelEvent_2eproto();
  friend void protobuf_ShutdownFile_HighLevelEvent_2eproto();

  void InitAsDefaultInstance();
  static CurveHaptic* default_instance_;
};
// -------------------------------------------------------------------

class RealtimeHaptic_Magnitude : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:NullSpaceIPC.RealtimeHaptic.Magnitude) */ {
 public:
  RealtimeHaptic_Magnitude();
  virtual ~RealtimeHaptic_Magnitude();

  RealtimeHaptic_Magnitude(const RealtimeHaptic_Magnitude& from);

  inline RealtimeHaptic_Magnitude& operator=(const RealtimeHaptic_Magnitude& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RealtimeHaptic_Magnitude& default_instance();

  void Swap(RealtimeHaptic_Magnitude* other);

  // implements Message ----------------------------------------------

  inline RealtimeHaptic_Magnitude* New() const { return New(NULL); }

  RealtimeHaptic_Magnitude* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RealtimeHaptic_Magnitude& from);
  void MergeFrom(const RealtimeHaptic_Magnitude& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(RealtimeHaptic_Magnitude* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 region = 1;
  void clear_region();
  static const int kRegionFieldNumber = 1;
  ::google::protobuf::uint32 region() const;
  void set_region(::google::protobuf::uint32 value);

  // optional float strength = 2;
  void clear_strength();
  static const int kStrengthFieldNumber = 2;
  float strength() const;
  void set_strength(float value);

  // @@protoc_insertion_point(class_scope:NullSpaceIPC.RealtimeHaptic.Magnitude)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::uint32 region_;
  float strength_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_HighLevelEvent_2eproto();
  friend void protobuf_AssignDesc_HighLevelEvent_2eproto();
  friend void protobuf_ShutdownFile_HighLevelEvent_2eproto();

  void InitAsDefaultInstance();
  static RealtimeHaptic_Magnitude* default_instance_;
};
// -------------------------------------------------------------------

class RealtimeHaptic : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:NullSpaceIPC.RealtimeHaptic) */ {
 public:
  RealtimeHaptic();
  virtual ~RealtimeHaptic();

  RealtimeHaptic(const RealtimeHaptic& from);

  inline RealtimeHaptic& operator=(const RealtimeHaptic& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RealtimeHaptic& default_instance();

  void Swap(RealtimeHaptic* other);

  // implements Message ----------------------------------------------

  inline RealtimeHaptic* New() const { return New(NULL); }

  RealtimeHaptic* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RealtimeHaptic& from);
  void MergeFrom(const RealtimeHaptic& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(RealtimeHaptic* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef RealtimeHaptic_Magnitude Magnitude;

  // accessors -------------------------------------------------------

  // repeated .NullSpaceIPC.RealtimeHaptic.Magnitude magnitudes = 1;
  int magnitudes_size() const;
  void clear_magnitudes();
  static const int kMagnitudesFieldNumber = 1;
  const ::NullSpaceIPC::RealtimeHaptic_Magnitude& magnitudes(int index) const;
  ::NullSpaceIPC::RealtimeHaptic_Magnitude* mutable_magnitudes(int index);
  ::NullSpaceIPC::RealtimeHaptic_Magnitude* add_magnitudes();
  ::google::protobuf::RepeatedPtrField< ::NullSpaceIPC::RealtimeHaptic_Magnitude >*
      mutable_magnitudes();
  const ::google::protobuf::RepeatedPtrField< ::NullSpaceIPC::RealtimeHaptic_Magnitude >&
      magnitudes() const;

  // @@protoc_insertion_point(class_scope:NullSpaceIPC.RealtimeHaptic)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::RepeatedPtrField< ::NullSpaceIPC::RealtimeHaptic_Magnitude > magnitudes_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_HighLevelEvent_2eproto();
  friend void protobuf_AssignDesc_HighLevelEvent_2eproto();
  friend void protobuf_ShutdownFile_HighLevelEvent_2eproto();

  void InitAsDefaultInstance();
  static RealtimeHaptic* default_instance_;
};
// -------------------------------------------------------------------

class PlaybackEvent : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:NullSpaceIPC.PlaybackEvent) */ {
 public:
  PlaybackEvent();
  virtual ~PlaybackEvent();

  PlaybackEvent(const PlaybackEvent& from);

  inline PlaybackEvent& operator=(const PlaybackEvent& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PlaybackEvent& default_instance();

  void Swap(PlaybackEvent* other);

  // implements Message ----------------------------------------------

  inline PlaybackEvent* New() const { return New(NULL); }

  PlaybackEvent* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PlaybackEvent& from);
  void MergeFrom(const PlaybackEvent& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(PlaybackEvent* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef PlaybackEvent_Command Command;
  static const Command UNKNOWN =
    PlaybackEvent_Command_UNKNOWN;
  static const Command PAUSE =
    PlaybackEvent_Command_PAUSE;
  static const Command UNPAUSE =
    PlaybackEvent_Command_UNPAUSE;
  static const Command CANCEL =
    PlaybackEvent_Command_CANCEL;
  static inline bool Command_IsValid(int value) {
    return PlaybackEvent_Command_IsValid(value);
  }
  static const Command Command_MIN =
    PlaybackEvent_Command_Command_MIN;
  static const Command Command_MAX =
    PlaybackEvent_Command_Command_MAX;
  static const int Command_ARRAYSIZE =
    PlaybackEvent_Command_Command_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Command_descriptor() {
    return PlaybackEvent_Command_descriptor();
  }
  static inline const ::std::string& Command_Name(Command value) {
    return PlaybackEvent_Command_Name(value);
  }
  static inline bool Command_Parse(const ::std::string& name,
      Command* value) {
    return PlaybackEvent_Command_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional .NullSpaceIPC.PlaybackEvent.Command command = 1;
  void clear_command();
  static const int kCommandFieldNumber = 1;
  ::NullSpaceIPC::PlaybackEvent_Command command() const;
  void set_command(::NullSpaceIPC::PlaybackEvent_Command value);

  // @@protoc_insertion_point(class_scope:NullSpaceIPC.PlaybackEvent)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  int command_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_HighLevelEvent_2eproto();
  friend void protobuf_AssignDesc_HighLevelEvent_2eproto();
  friend void protobuf_ShutdownFile_HighLevelEvent_2eproto();

  void InitAsDefaultInstance();
  static PlaybackEvent* default_instance_;
};
// -------------------------------------------------------------------

class HighLevelEvent : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:NullSpaceIPC.HighLevelEvent) */ {
 public:
  HighLevelEvent();
  virtual ~HighLevelEvent();

  HighLevelEvent(const HighLevelEvent& from);

  inline HighLevelEvent& operator=(const HighLevelEvent& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const HighLevelEvent& default_instance();

  enum EventsCase {
    kPlaybackEvent = 2,
    kSimpleHaptic = 3,
    kRealtimeHaptic = 4,
    kCurveHaptic = 5,
    EVENTS_NOT_SET = 0,
  };

  void Swap(HighLevelEvent* other);

  // implements Message ----------------------------------------------

  inline HighLevelEvent* New() const { return New(NULL); }

  HighLevelEvent* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const HighLevelEvent& from);
  void MergeFrom(const HighLevelEvent& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(HighLevelEvent* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint64 parent_id = 1;
  void clear_parent_id();
  static const int kParentIdFieldNumber = 1;
  ::google::protobuf::uint64 parent_id() const;
  void set_parent_id(::google::protobuf::uint64 value);

  // optional .NullSpaceIPC.PlaybackEvent playback_event = 2;
  bool has_playback_event() const;
  void clear_playback_event();
  static const int kPlaybackEventFieldNumber = 2;
  const ::NullSpaceIPC::PlaybackEvent& playback_event() const;
  ::NullSpaceIPC::PlaybackEvent* mutable_playback_event();
  ::NullSpaceIPC::PlaybackEvent* release_playback_event();
  void set_allocated_playback_event(::NullSpaceIPC::PlaybackEvent* playback_event);

  // optional .NullSpaceIPC.SimpleHaptic simple_haptic = 3;
  bool has_simple_haptic() const;
  void clear_simple_haptic();
  static const int kSimpleHapticFieldNumber = 3;
  const ::NullSpaceIPC::SimpleHaptic& simple_haptic() const;
  ::NullSpaceIPC::SimpleHaptic* mutable_simple_haptic();
  ::NullSpaceIPC::SimpleHaptic* release_simple_haptic();
  void set_allocated_simple_haptic(::NullSpaceIPC::SimpleHaptic* simple_haptic);

  // optional .NullSpaceIPC.RealtimeHaptic realtime_haptic = 4;
  bool has_realtime_haptic() const;
  void clear_realtime_haptic();
  static const int kRealtimeHapticFieldNumber = 4;
  const ::NullSpaceIPC::RealtimeHaptic& realtime_haptic() const;
  ::NullSpaceIPC::RealtimeHaptic* mutable_realtime_haptic();
  ::NullSpaceIPC::RealtimeHaptic* release_realtime_haptic();
  void set_allocated_realtime_haptic(::NullSpaceIPC::RealtimeHaptic* realtime_haptic);

  // optional .NullSpaceIPC.CurveHaptic curve_haptic = 5;
  bool has_curve_haptic() const;
  void clear_curve_haptic();
  static const int kCurveHapticFieldNumber = 5;
  const ::NullSpaceIPC::CurveHaptic& curve_haptic() const;
  ::NullSpaceIPC::CurveHaptic* mutable_curve_haptic();
  ::NullSpaceIPC::CurveHaptic* release_curve_haptic();
  void set_allocated_curve_haptic(::NullSpaceIPC::CurveHaptic* curve_haptic);

  EventsCase events_case() const;
  // @@protoc_insertion_point(class_scope:NullSpaceIPC.HighLevelEvent)
 private:
  inline void set_has_playback_event();
  inline void set_has_simple_haptic();
  inline void set_has_realtime_haptic();
  inline void set_has_curve_haptic();

  inline bool has_events() const;
  void clear_events();
  inline void clear_has_events();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::uint64 parent_id_;
  union EventsUnion {
    EventsUnion() {}
    ::NullSpaceIPC::PlaybackEvent* playback_event_;
    ::NullSpaceIPC::SimpleHaptic* simple_haptic_;
    ::NullSpaceIPC::RealtimeHaptic* realtime_haptic_;
    ::NullSpaceIPC::CurveHaptic* curve_haptic_;
  } events_;
  mutable int _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend void  protobuf_AddDesc_HighLevelEvent_2eproto();
  friend void protobuf_AssignDesc_HighLevelEvent_2eproto();
  friend void protobuf_ShutdownFile_HighLevelEvent_2eproto();

  void InitAsDefaultInstance();
  static HighLevelEvent* default_instance_;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
// SimpleHaptic

// repeated uint32 regions = 1;
inline int SimpleHaptic::regions_size() const {
  return regions_.size();
}
inline void SimpleHaptic::clear_regions() {
  regions_.Clear();
}
inline ::google::protobuf::uint32 SimpleHaptic::regions(int index) const {
  // @@protoc_insertion_point(field_get:NullSpaceIPC.SimpleHaptic.regions)
  return regions_.Get(index);
}
inline void SimpleHaptic::set_regions(int index, ::google::protobuf::uint32 value) {
  regions_.Set(index, value);
  // @@protoc_insertion_point(field_set:NullSpaceIPC.SimpleHaptic.regions)
}
inline void SimpleHaptic::add_regions(::google::protobuf::uint32 value) {
  regions_.Add(value);
  // @@protoc_insertion_point(field_add:NullSpaceIPC.SimpleHaptic.regions)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
SimpleHaptic::regions() const {
  // @@protoc_insertion_point(field_list:NullSpaceIPC.SimpleHaptic.regions)
  return regions_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
SimpleHaptic::mutable_regions() {
  // @@protoc_insertion_point(field_mutable_list:NullSpaceIPC.SimpleHaptic.regions)
  return &regions_;
}

// optional uint32 effect = 2;
inline void SimpleHaptic::clear_effect() {
  effect_ = 0u;
}
inline ::google::protobuf::uint32 SimpleHaptic::effect() const {
  // @@protoc_insertion_point(field_get:NullSpaceIPC.SimpleHaptic.effect)
  return effect_;
}
inline void SimpleHaptic::set_effect(::google::protobuf::uint32 value) {
  
  effect_ = value;
  // @@protoc_insertion_point(field_set:NullSpaceIPC.SimpleHaptic.effect)
}

// optional float strength = 3;
inline void SimpleHaptic::clear_strength() {
  strength_ = 0;
}
inline float SimpleHaptic::strength() const {
  // @@protoc_insertion_point(field_get:NullSpaceIPC.SimpleHaptic.strength)
  return strength_;
}
inline void SimpleHaptic::set_strength(float value) {
  
  strength_ = value;
  // @@protoc_insertion_point(field_set:NullSpaceIPC.SimpleHaptic.strength)
}

// optional float duration = 4;
inline void SimpleHaptic::clear_duration() {
  duration_ = 0;
}
inline float SimpleHaptic::duration() const {
  // @@protoc_insertion_point(field_get:NullSpaceIPC.SimpleHaptic.duration)
  return duration_;
}
inline void SimpleHaptic::set_duration(float value) {
  
  duration_ = value;
  // @@protoc_insertion_point(field_set:NullSpaceIPC.SimpleHaptic.duration)
}

// -------------------------------------------------------------------

// CurveHaptic_Sample

// optional float time = 1;
inline void CurveHaptic_Sample::clear_time() {
  time_ = 0;
}
inline float CurveHaptic_Sample::time() const {
  // @@protoc_insertion_point(field_get:NullSpaceIPC.CurveHaptic.Sample.time)
  return time_;
}
inline void CurveHaptic_Sample::set_time(float value) {
  
  time_ = value;
  // @@protoc_insertion_point(field_set:NullSpaceIPC.CurveHaptic.Sample.time)
}

// optional float magnitude = 2;
inline void CurveHaptic_Sample::clear_magnitude() {
  magnitude_ = 0;
}
inline float CurveHaptic_Sample::magnitude() const {
  // @@protoc_insertion_point(field_get:NullSpaceIPC.CurveHaptic.Sample.magnitude)
  return magnitude_;
}
inline void CurveHaptic_Sample::set_magnitude(float value) {
  
  magnitude_ = value;
  // @@protoc_insertion_point(field_set:NullSpaceIPC.CurveHaptic.Sample.magnitude)
}

// -------------------------------------------------------------------

// CurveHaptic

// repeated uint64 regions = 1;
inline int CurveHaptic::regions_size() const {
  return regions_.size();
}
inline void CurveHaptic::clear_regions() {
  regions_.Clear();
}
inline ::google::protobuf::uint64 CurveHaptic::regions(int index) const {
  // @@protoc_insertion_point(field_get:NullSpaceIPC.CurveHaptic.regions)
  return regions_.Get(index);
}
inline void CurveHaptic::set_regions(int index, ::google::protobuf::uint64 value) {
  regions_.Set(index, value);
  // @@protoc_insertion_point(field_set:NullSpaceIPC.CurveHaptic.regions)
}
inline void CurveHaptic::add_regions(::google::protobuf::uint64 value) {
  regions_.Add(value);
  // @@protoc_insertion_point(field_add:NullSpaceIPC.CurveHaptic.regions)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
CurveHaptic::regions() const {
  // @@protoc_insertion_point(field_list:NullSpaceIPC.CurveHaptic.regions)
  return regions_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
CurveHaptic::mutable_regions() {
  // @@protoc_insertion_point(field_mutable_list:NullSpaceIPC.CurveHaptic.regions)
  return &regions_;
}

// repeated .NullSpaceIPC.CurveHaptic.Sample samples = 2;
inline int CurveHaptic::samples_size() const {
  return samples_.size();
}
inline void CurveHaptic::clear_samples() {
  samples_.Clear();
}
inline const ::NullSpaceIPC::CurveHaptic_Sample& CurveHaptic::samples(int index) const {
  // @@protoc_insertion_point(field_get:NullSpaceIPC.CurveHaptic.samples)
  return samples_.Get(index);
}
inline ::NullSpaceIPC::CurveHaptic_Sample* CurveHaptic::mutable_samples(int index) {
  // @@protoc_insertion_point(field_mutable:NullSpaceIPC.CurveHaptic.samples)
  return samples_.Mutable(index);
}
inline ::NullSpaceIPC::CurveHaptic_Sample* CurveHaptic::add_samples() {
  // @@protoc_insertion_point(field_add:NullSpaceIPC.CurveHaptic.samples)
  return samples_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::NullSpaceIPC::CurveHaptic_Sample >*
CurveHaptic::mutable_samples() {
  // @@protoc_insertion_point(field_mutable_list:NullSpaceIPC.CurveHaptic.samples)
  return &samples_;
}
inline const ::google::protobuf::RepeatedPtrField< ::NullSpaceIPC::CurveHaptic_Sample >&
CurveHaptic::samples() const {
  // @@protoc_insertion_point(field_list:NullSpaceIPC.CurveHaptic.samples)
  return samples_;
}

// -------------------------------------------------------------------

// RealtimeHaptic_Magnitude

// optional uint32 region = 1;
inline void RealtimeHaptic_Magnitude::clear_region() {
  region_ = 0u;
}
inline ::google::protobuf::uint32 RealtimeHaptic_Magnitude::region() const {
  // @@protoc_insertion_point(field_get:NullSpaceIPC.RealtimeHaptic.Magnitude.region)
  return region_;
}
inline void RealtimeHaptic_Magnitude::set_region(::google::protobuf::uint32 value) {
  
  region_ = value;
  // @@protoc_insertion_point(field_set:NullSpaceIPC.RealtimeHaptic.Magnitude.region)
}

// optional float strength = 2;
inline void RealtimeHaptic_Magnitude::clear_strength() {
  strength_ = 0;
}
inline float RealtimeHaptic_Magnitude::strength() const {
  // @@protoc_insertion_point(field_get:NullSpaceIPC.RealtimeHaptic.Magnitude.strength)
  return strength_;
}
inline void RealtimeHaptic_Magnitude::set_strength(float value) {
  
  strength_ = value;
  // @@protoc_insertion_point(field_set:NullSpaceIPC.RealtimeHaptic.Magnitude.strength)
}

// -------------------------------------------------------------------

// RealtimeHaptic

// repeated .NullSpaceIPC.RealtimeHaptic.Magnitude magnitudes = 1;
inline int RealtimeHaptic::magnitudes_size() const {
  return magnitudes_.size();
}
inline void RealtimeHaptic::clear_magnitudes() {
  magnitudes_.Clear();
}
inline const ::NullSpaceIPC::RealtimeHaptic_Magnitude& RealtimeHaptic::magnitudes(int index) const {
  // @@protoc_insertion_point(field_get:NullSpaceIPC.RealtimeHaptic.magnitudes)
  return magnitudes_.Get(index);
}
inline ::NullSpaceIPC::RealtimeHaptic_Magnitude* RealtimeHaptic::mutable_magnitudes(int index) {
  // @@protoc_insertion_point(field_mutable:NullSpaceIPC.RealtimeHaptic.magnitudes)
  return magnitudes_.Mutable(index);
}
inline ::NullSpaceIPC::RealtimeHaptic_Magnitude* RealtimeHaptic::add_magnitudes() {
  // @@protoc_insertion_point(field_add:NullSpaceIPC.RealtimeHaptic.magnitudes)
  return magnitudes_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::NullSpaceIPC::RealtimeHaptic_Magnitude >*
RealtimeHaptic::mutable_magnitudes() {
  // @@protoc_insertion_point(field_mutable_list:NullSpaceIPC.RealtimeHaptic.magnitudes)
  return &magnitudes_;
}
inline const ::google::protobuf::RepeatedPtrField< ::NullSpaceIPC::RealtimeHaptic_Magnitude >&
RealtimeHaptic::magnitudes() const {
  // @@protoc_insertion_point(field_list:NullSpaceIPC.RealtimeHaptic.magnitudes)
  return magnitudes_;
}

// -------------------------------------------------------------------

// PlaybackEvent

// optional .NullSpaceIPC.PlaybackEvent.Command command = 1;
inline void PlaybackEvent::clear_command() {
  command_ = 0;
}
inline ::NullSpaceIPC::PlaybackEvent_Command PlaybackEvent::command() const {
  // @@protoc_insertion_point(field_get:NullSpaceIPC.PlaybackEvent.command)
  return static_cast< ::NullSpaceIPC::PlaybackEvent_Command >(command_);
}
inline void PlaybackEvent::set_command(::NullSpaceIPC::PlaybackEvent_Command value) {
  
  command_ = value;
  // @@protoc_insertion_point(field_set:NullSpaceIPC.PlaybackEvent.command)
}

// -------------------------------------------------------------------

// HighLevelEvent

// optional uint64 parent_id = 1;
inline void HighLevelEvent::clear_parent_id() {
  parent_id_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 HighLevelEvent::parent_id() const {
  // @@protoc_insertion_point(field_get:NullSpaceIPC.HighLevelEvent.parent_id)
  return parent_id_;
}
inline void HighLevelEvent::set_parent_id(::google::protobuf::uint64 value) {
  
  parent_id_ = value;
  // @@protoc_insertion_point(field_set:NullSpaceIPC.HighLevelEvent.parent_id)
}

// optional .NullSpaceIPC.PlaybackEvent playback_event = 2;
inline bool HighLevelEvent::has_playback_event() const {
  return events_case() == kPlaybackEvent;
}
inline void HighLevelEvent::set_has_playback_event() {
  _oneof_case_[0] = kPlaybackEvent;
}
inline void HighLevelEvent::clear_playback_event() {
  if (has_playback_event()) {
    delete events_.playback_event_;
    clear_has_events();
  }
}
inline  const ::NullSpaceIPC::PlaybackEvent& HighLevelEvent::playback_event() const {
  // @@protoc_insertion_point(field_get:NullSpaceIPC.HighLevelEvent.playback_event)
  return has_playback_event()
      ? *events_.playback_event_
      : ::NullSpaceIPC::PlaybackEvent::default_instance();
}
inline ::NullSpaceIPC::PlaybackEvent* HighLevelEvent::mutable_playback_event() {
  if (!has_playback_event()) {
    clear_events();
    set_has_playback_event();
    events_.playback_event_ = new ::NullSpaceIPC::PlaybackEvent;
  }
  // @@protoc_insertion_point(field_mutable:NullSpaceIPC.HighLevelEvent.playback_event)
  return events_.playback_event_;
}
inline ::NullSpaceIPC::PlaybackEvent* HighLevelEvent::release_playback_event() {
  // @@protoc_insertion_point(field_release:NullSpaceIPC.HighLevelEvent.playback_event)
  if (has_playback_event()) {
    clear_has_events();
    ::NullSpaceIPC::PlaybackEvent* temp = events_.playback_event_;
    events_.playback_event_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void HighLevelEvent::set_allocated_playback_event(::NullSpaceIPC::PlaybackEvent* playback_event) {
  clear_events();
  if (playback_event) {
    set_has_playback_event();
    events_.playback_event_ = playback_event;
  }
  // @@protoc_insertion_point(field_set_allocated:NullSpaceIPC.HighLevelEvent.playback_event)
}

// optional .NullSpaceIPC.SimpleHaptic simple_haptic = 3;
inline bool HighLevelEvent::has_simple_haptic() const {
  return events_case() == kSimpleHaptic;
}
inline void HighLevelEvent::set_has_simple_haptic() {
  _oneof_case_[0] = kSimpleHaptic;
}
inline void HighLevelEvent::clear_simple_haptic() {
  if (has_simple_haptic()) {
    delete events_.simple_haptic_;
    clear_has_events();
  }
}
inline  const ::NullSpaceIPC::SimpleHaptic& HighLevelEvent::simple_haptic() const {
  // @@protoc_insertion_point(field_get:NullSpaceIPC.HighLevelEvent.simple_haptic)
  return has_simple_haptic()
      ? *events_.simple_haptic_
      : ::NullSpaceIPC::SimpleHaptic::default_instance();
}
inline ::NullSpaceIPC::SimpleHaptic* HighLevelEvent::mutable_simple_haptic() {
  if (!has_simple_haptic()) {
    clear_events();
    set_has_simple_haptic();
    events_.simple_haptic_ = new ::NullSpaceIPC::SimpleHaptic;
  }
  // @@protoc_insertion_point(field_mutable:NullSpaceIPC.HighLevelEvent.simple_haptic)
  return events_.simple_haptic_;
}
inline ::NullSpaceIPC::SimpleHaptic* HighLevelEvent::release_simple_haptic() {
  // @@protoc_insertion_point(field_release:NullSpaceIPC.HighLevelEvent.simple_haptic)
  if (has_simple_haptic()) {
    clear_has_events();
    ::NullSpaceIPC::SimpleHaptic* temp = events_.simple_haptic_;
    events_.simple_haptic_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void HighLevelEvent::set_allocated_simple_haptic(::NullSpaceIPC::SimpleHaptic* simple_haptic) {
  clear_events();
  if (simple_haptic) {
    set_has_simple_haptic();
    events_.simple_haptic_ = simple_haptic;
  }
  // @@protoc_insertion_point(field_set_allocated:NullSpaceIPC.HighLevelEvent.simple_haptic)
}

// optional .NullSpaceIPC.RealtimeHaptic realtime_haptic = 4;
inline bool HighLevelEvent::has_realtime_haptic() const {
  return events_case() == kRealtimeHaptic;
}
inline void HighLevelEvent::set_has_realtime_haptic() {
  _oneof_case_[0] = kRealtimeHaptic;
}
inline void HighLevelEvent::clear_realtime_haptic() {
  if (has_realtime_haptic()) {
    delete events_.realtime_haptic_;
    clear_has_events();
  }
}
inline  const ::NullSpaceIPC::RealtimeHaptic& HighLevelEvent::realtime_haptic() const {
  // @@protoc_insertion_point(field_get:NullSpaceIPC.HighLevelEvent.realtime_haptic)
  return has_realtime_haptic()
      ? *events_.realtime_haptic_
      : ::NullSpaceIPC::RealtimeHaptic::default_instance();
}
inline ::NullSpaceIPC::RealtimeHaptic* HighLevelEvent::mutable_realtime_haptic() {
  if (!has_realtime_haptic()) {
    clear_events();
    set_has_realtime_haptic();
    events_.realtime_haptic_ = new ::NullSpaceIPC::RealtimeHaptic;
  }
  // @@protoc_insertion_point(field_mutable:NullSpaceIPC.HighLevelEvent.realtime_haptic)
  return events_.realtime_haptic_;
}
inline ::NullSpaceIPC::RealtimeHaptic* HighLevelEvent::release_realtime_haptic() {
  // @@protoc_insertion_point(field_release:NullSpaceIPC.HighLevelEvent.realtime_haptic)
  if (has_realtime_haptic()) {
    clear_has_events();
    ::NullSpaceIPC::RealtimeHaptic* temp = events_.realtime_haptic_;
    events_.realtime_haptic_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void HighLevelEvent::set_allocated_realtime_haptic(::NullSpaceIPC::RealtimeHaptic* realtime_haptic) {
  clear_events();
  if (realtime_haptic) {
    set_has_realtime_haptic();
    events_.realtime_haptic_ = realtime_haptic;
  }
  // @@protoc_insertion_point(field_set_allocated:NullSpaceIPC.HighLevelEvent.realtime_haptic)
}

// optional .NullSpaceIPC.CurveHaptic curve_haptic = 5;
inline bool HighLevelEvent::has_curve_haptic() const {
  return events_case() == kCurveHaptic;
}
inline void HighLevelEvent::set_has_curve_haptic() {
  _oneof_case_[0] = kCurveHaptic;
}
inline void HighLevelEvent::clear_curve_haptic() {
  if (has_curve_haptic()) {
    delete events_.curve_haptic_;
    clear_has_events();
  }
}
inline  const ::NullSpaceIPC::CurveHaptic& HighLevelEvent::curve_haptic() const {
  // @@protoc_insertion_point(field_get:NullSpaceIPC.HighLevelEvent.curve_haptic)
  return has_curve_haptic()
      ? *events_.curve_haptic_
      : ::NullSpaceIPC::CurveHaptic::default_instance();
}
inline ::NullSpaceIPC::CurveHaptic* HighLevelEvent::mutable_curve_haptic() {
  if (!has_curve_haptic()) {
    clear_events();
    set_has_curve_haptic();
    events_.curve_haptic_ = new ::NullSpaceIPC::CurveHaptic;
  }
  // @@protoc_insertion_point(field_mutable:NullSpaceIPC.HighLevelEvent.curve_haptic)
  return events_.curve_haptic_;
}
inline ::NullSpaceIPC::CurveHaptic* HighLevelEvent::release_curve_haptic() {
  // @@protoc_insertion_point(field_release:NullSpaceIPC.HighLevelEvent.curve_haptic)
  if (has_curve_haptic()) {
    clear_has_events();
    ::NullSpaceIPC::CurveHaptic* temp = events_.curve_haptic_;
    events_.curve_haptic_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void HighLevelEvent::set_allocated_curve_haptic(::NullSpaceIPC::CurveHaptic* curve_haptic) {
  clear_events();
  if (curve_haptic) {
    set_has_curve_haptic();
    events_.curve_haptic_ = curve_haptic;
  }
  // @@protoc_insertion_point(field_set_allocated:NullSpaceIPC.HighLevelEvent.curve_haptic)
}

inline bool HighLevelEvent::has_events() const {
  return events_case() != EVENTS_NOT_SET;
}
inline void HighLevelEvent::clear_has_events() {
  _oneof_case_[0] = EVENTS_NOT_SET;
}
inline HighLevelEvent::EventsCase HighLevelEvent::events_case() const {
  return HighLevelEvent::EventsCase(_oneof_case_[0]);
}
#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace NullSpaceIPC

#ifndef SWIG
namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::NullSpaceIPC::PlaybackEvent_Command> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::NullSpaceIPC::PlaybackEvent_Command>() {
  return ::NullSpaceIPC::PlaybackEvent_Command_descriptor();
}

}  // namespace protobuf
}  // namespace google
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_HighLevelEvent_2eproto__INCLUDED
